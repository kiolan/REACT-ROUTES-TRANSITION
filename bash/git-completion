
#!bash
#
# bash completion support for core Git.
#
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
# Conceptually based on gitcompletion (http://gitweb.hawaga.org.uk/).
# Distributed under the GNU General Public License, version 2.0.
#
# The contained completion routines provide support for completing:
#
#    *) local and remote branch names
#    *) local and remote tag names
#    *) .git/remotes file names
#    *) git 'subcommands'
#    *) tree paths within 'ref:path/to/file' expressions
#    *) common --long-options
#
# To use these routines:
#
#    1) Copy this file to somewhere (e.g. ~/.git-completion.sh).
#    2) Added the following line to your .bashrc:
#        source ~/.git-completion.sh
#
#    3) Consider changing your PS1 to also show the current branch:
#        PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
#
#       The argument to __git_ps1 will be displayed only if you
#       are currently in a git repository.  The %s token will be
#       the name of the current branch.
#
#       In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty
#       value, unstaged (*) and staged (+) changes will be shown next
#       to the branch name.  You can configure this per-repository
#       with the bash.showDirtyState variable, which defaults to true
#       once GIT_PS1_SHOWDIRTYSTATE is enabled.
#
#       You can also see if currently something is stashed, by setting
#       GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,
#       then a '$' will be shown next to the branch name.
#
#       If you would like to see if there're untracked files, then you can
#       set GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're
#       untracked files, then a '%' will be shown next to the branch name.
#
#       If you would like to see the difference between HEAD and its
#       upstream, set GIT_PS1_SHOWUPSTREAM="auto".  A "<" indicates
#       you are behind, ">" indicates you are ahead, and "<>"
#       indicates you have diverged.  You can further control
#       behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated
#       list of values:
#           verbose       show number of commits ahead/behind (+/-) upstream
#           legacy        don't use the '--count' option available in recent
#                         versions of git-rev-list
#           git           always compare HEAD to @{upstream}
#           svn           always compare HEAD to your SVN upstream
#       By default, __git_ps1 will compare HEAD to your SVN upstream
#       if it can find one, or @{upstream} otherwise.  Once you have
#       set GIT_PS1_SHOWUPSTREAM, you can override it on a
#       per-repository basis by setting the bash.showUpstream config
#       variable.
#
#
# To submit patches:
#
#    *) Read Documentation/SubmittingPatches
#    *) Send all patches to the current maintainer:
#
#       "Shawn O. Pearce" <spearce@spearce.org>
#
#    *) Always CC the Git mailing list:
#
#       git@vger.kernel.org
#

case "$COMP_WORDBREAKS" in
*:*) : great ;;
*)   COMP_WORDBREAKS="$COMP_WORDBREAKS:"
esac

# __gitdir accepts 0 or 1 arguments (i.e., location)
# returns location of .git repo
__gitdir ()
{
  if [ -z "${1-}" ]; then
    if [ -n "${__git_dir-}" ]; then
      echo "$__git_dir"
    elif [ -d .git ]; then
      echo .git
    else
      git rev-parse --git-dir 2>/dev/null
    fi
  elif [ -d "$1/.git" ]; then
    echo "$1/.git"
  else
    echo "$1"
  fi
}

# stores the divergence from upstream in $p
# used by GIT_PS1_SHOWUPSTREAM
__git_ps1_show_upstream ()
{
  local key value
  local svn_remote=() svn_url_pattern count n
  local upstream=git legacy="" verbose=""

  # get some config options from git-config
  while read key value; do
    case "$key" in
    bash.showupstream)
      GIT_PS1_SHOWUPSTREAM="$value"
      if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
        p=""
        return
      fi
      ;;
    svn-remote.*.url)
      svn_remote[ $((${#svn_remote[@]} + 1)) ]="$value"
      svn_url_pattern+="\\|$value"
      upstream=svn+git # default upstream is SVN if available, else git
      ;;
    esac
  done < <(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')

  # parse configuration values
  for option in ${GIT_PS1_SHOWUPSTREAM}; do
    case "$option" in
    git|svn) upstream="$option" ;;
    verbose) verbose=1 ;;
    legacy)  legacy=1  ;;
    esac
  done

  # Find our upstream
  case "$upstream" in
  git)    upstream="@{upstream}" ;;
  svn*)
    # get the upstream from the "git-svn-id: ..." in a commit message
    # (git-svn uses essentially the same procedure internally)
    local svn_upstream=($(git log --first-parent -1 \
          --grep="^git-svn-id: \(${svn_url_pattern:2}\)" 2>/dev/null))
    if [[ 0 -ne ${#svn_upstream[@]} ]]; then
      svn_upstream=${svn_upstream[ ${#svn_upstream[@]} - 2 ]}
      svn_upstream=${svn_upstream%@*}
      for ((n=1; "$n" <= "${#svn_remote[@]}"; ++n)); do
        svn_upstream=${svn_upstream#${svn_remote[$n]}}
      done

      if [[ -z "$svn_upstream" ]]; then
        # default branch name for checkouts with no layout:
        upstream=${GIT_SVN_ID:-git-svn}
      else
        upstream=${svn_upstream#/}
      fi
    elif [[ "svn+git" = "$upstream" ]]; then
      upstream="@{upstream}"
    fi
    ;;
  esac

  # Find how many commits we are ahead/behind our upstream
  if [[ -z "$legacy" ]]; then
    count="$(git rev-list --count --left-right \
        "$upstream"...HEAD 2>/dev/null)"
  else
    # produce equivalent output to --count for older versions of git
    local commits
    if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"
    then
      local commit behind=0 ahead=0
      for commit in $commits
      do
        case "$commit" in
        "<"*) let ++behind
          ;;
        *)    let ++ahead
          ;;
        esac
      done
      count="$behind  $ahead"
    else
      count=""
    fi
  fi

  # calculate the result
  if [[ -z "$verbose" ]]; then
    case "$count" in
    "") # no upstream
      p="" ;;
    "0  0") # equal to upstream
      p="=" ;;
    "0  "*) # ahead of upstream
      p=">" ;;
    *"  0") # behind upstream
      p="<" ;;
    *)      # diverged from upstream
      p="<>" ;;
    esac
  else
    case "$count" in
    "") # no upstream
      p="" ;;
    "0  0") # equal to upstream
      p=" u=" ;;
    "0  "*) # ahead of upstream
      p=" u+${count#0  }" ;;
    *"  0") # behind upstream
      p=" u-${count%  0}" ;;
    *)      # diverged from upstream
      p=" u+${count#*  }-${count%  *}" ;;
    esac
  fi

}


# __git_ps1 accepts 0 or 1 arguments (i.e., format string)
# returns text to add to bash PS1 prompt (includes branch name)
__git_ps1 ()
{
  local g="$(__gitdir)"
  if [ -n "$g" ]; then
    local r=""
    local b=""
    if [ -f "$g/rebase-merge/interactive" ]; then
      r="|REBASE-i"
      b="$(cat "$g/rebase-merge/head-name")"
    elif [ -d "$g/rebase-merge" ]; then
      r="|REBASE-m"
      b="$(cat "$g/rebase-merge/head-name")"
    else
      if [ -d "$g/rebase-apply" ]; then
        if [ -f "$g/rebase-apply/rebasing" ]; then
          r="|REBASE"
        elif [ -f "$g/rebase-apply/applying" ]; then
          r="|AM"
        else
          r="|AM/REBASE"
        fi
      elif [ -f "$g/MERGE_HEAD" ]; then
        r="|MERGING"
      elif [ -f "$g/BISECT_LOG" ]; then
        r="|BISECTING"
      fi

      b="$(git symbolic-ref HEAD 2>/dev/null)" || {

        b="$(
        case "${GIT_PS1_DESCRIBE_STYLE-}" in
        (contains)
          git describe --contains HEAD ;;
        (branch)
          git describe --contains --all HEAD ;;
        (describe)
          git describe HEAD ;;
        (* | default)
          git describe --exact-match HEAD ;;
        esac 2>/dev/null)" ||

        b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." ||
        b="unknown"
        b="($b)"
      }
    fi

    local w=""
    local i=""
    local s=""
    local u=""
    local c=""
    local p=""

    if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
      if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
        c="BARE:"
      else
        b="GIT_DIR!"
      fi
    elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
      if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ]; then
        if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
          git diff --no-ext-diff --quiet --exit-code || w="*"
          if git rev-parse --quiet --verify HEAD >/dev/null; then
            git diff-index --cached --quiet HEAD -- || i="+"
          else
            i="#"
          fi
        fi
      fi
      if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
              git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
      fi

      if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
         if [ -n "$(git ls-files --others --exclude-standard)" ]; then
            u="%"
         fi
      fi

      if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
        __git_ps1_show_upstream
      fi
    fi

    local f="$w$i$s$u"
    printf "${1:- (%s)}" "$c${b##refs/heads/}${f:+ $f}$r$p"
  fi
}

# __gitcomp_1 requires 2 arguments
__gitcomp_1 ()
{
  local c IFS=' '$'\t'$'\n'
  for c in $1; do
    case "$c$2" in
    --*=*) printf %s$'\n' "$c$2" ;;
    *.)    printf %s$'\n' "$c$2" ;;
    *)     printf %s$'\n' "$c$2 " ;;
    esac
  done
}

# __gitcomp accepts 1, 2, 3, or 4 arguments
# generates completion reply with compgen
__gitcomp ()
{
  local cur="${COMP_WORDS[COMP_CWORD]}"
  if [ $# -gt 2 ]; then
    cur="$3"
  fi
  case "$cur" in
  --*=)
    COMPREPLY=()
    ;;
  *)
    local IFS=$'\n'
    COMPREPLY=($(compgen -P "${2-}" \
      -W "$(__gitcomp_1 "${1-}" "${4-}")" \
      -- "$cur"))
    ;;
  esac
}

# __git_heads accepts 0 or 1 arguments (to pass to __gitdir)
__git_heads ()
{
  local cmd i is_hash=y dir="$(__gitdir "${1-}")"
  if [ -d "$dir" ]; then
    git --git-dir="$dir" for-each-ref --format='%(refname:short)' \
      refs/heads
    return
  fi
  for i in $(git ls-remote "${1-}" 2>/dev/null); do
    case "$is_hash,$i" in
    y,*) is_hash=n ;;
    n,*^{}) is_hash=y ;;
    n,refs/heads/*) is_hash=y; echo "${i#refs/heads/}" ;;
    n,*) is_hash=y; echo "$i" ;;
    esac
  done
}

# __git_tags accepts 0 or 1 arguments (to pass to __gitdir)
__git_tags ()
{
  local cmd i is_hash=y dir="$(__gitdir "${1-}")"
  if [ -d "$dir" ]; then
    git --git-dir="$dir" for-each-ref --format='%(refname:short)' \
      refs/tags
    return
  fi
  for i in $(git ls-remote "${1-}" 2>/dev/null); do
    case "$is_hash,$i" in
    y,*) is_hash=n ;;
    n,*^{}) is_hash=y ;;
    n,refs/tags/*) is_hash=y; echo "${i#refs/tags/}" ;;
    n,*) is_hash=y; echo "$i" ;;
    esac
  done
}

# __git_refs accepts 0 or 1 arguments (to pass to __gitdir)
__git_refs ()
{
  local i is_hash=y dir="$(__gitdir "${1-}")"
  local cur="${COMP_WORDS[COMP_CWORD]}" format refs
  if [ -d "$dir" ]; then
    case "$cur" in
    refs|refs/*)
      format="refname"
      refs="${cur%/*}"
      ;;
    *)
      for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD; do
        if [ -e "$dir/$i" ]; then echo $i; fi
      done
      format="refname:short"
      refs="refs/tags refs/heads refs/remotes"
      ;;
    esac
    git --git-dir="$dir" for-each-ref --format="%($format)" \
      $refs
    return
  fi
  for i in $(git ls-remote "$dir" 2>/dev/null); do
    case "$is_hash,$i" in
    y,*) is_hash=n ;;
    n,*^{}) is_hash=y ;;
    n,refs/tags/*) is_hash=y; echo "${i#refs/tags/}" ;;
    n,refs/heads/*) is_hash=y; echo "${i#refs/heads/}" ;;
    n,refs/remotes/*) is_hash=y; echo "${i#refs/remotes/}" ;;
    n,*) is_hash=y; echo "$i" ;;
    esac
  done
}

# __git_refs2 requires 1 argument (to pass to __git_refs)
__git_refs2 ()
{
  local i
  for i in $(__git_refs "$1"); do
    echo "$i:$i"
  done
}

# __git_refs_remotes requires 1 argument (to pass to ls-remote)
__git_refs_remotes ()
{
  local cmd i is_hash=y
  for i in $(git ls-remote "$1" 2>/dev/null); do
    case "$is_hash,$i" in
    n,refs/heads/*)
      is_hash=y
      echo "$i:refs/remotes/$1/${i#refs/heads/}"
      ;;
    y,*) is_hash=n ;;
    n,*^{}) is_hash=y ;;
    n,refs/tags/*) is_hash=y;;
    n,*) is_hash=y; ;;
    esac
  done
}

__git_remotes ()
{
  local i ngoff IFS=$'\n' d="$(__gitdir)"
  shopt -q nullglob || ngoff=1
  shopt -s nullglob
  for i in "$d/remotes"/*; do
    echo ${i#$d/remotes/}
  done
  [ "$ngoff" ] && shopt -u nullglob
  for i in $(git --git-dir="$d" config --get-regexp 'remote\..*\.url' 2>/dev/null); do
    i="${i#remote.}"
    echo "${i/.url*/}"
  done
}

__git_list_merge_strategies ()
{
  git merge -s help 2>&1 |
  sed -n -e '/[Aa]vailable strategies are: /,/^$/{
    s/\.$//
    s/.*://
    s/^[   ]*//
    s/[   ]*$//
    p
  }'
}

__git_merge_strategies=
# 'git merge -s help' (and thus detection of the merge strategy
# list) fails, unfortunately, if run outside of any git working
# tree.  __git_merge_strategies is set to the empty string in
# that case, and the detection will be repeated the next time it
# is needed.
__git_compute_merge_strategies ()
{
  : ${__git_merge_strategies:=$(__git_list_merge_strategies)}
}

__git_complete_file ()
{
  local pfx ls ref cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  ?*:*)
    ref="${cur%%:*}"
    cur="${cur#*:}"
    case "$cur" in
    ?*/*)
      pfx="${cur%/*}"
      cur="${cur##*/}"
      ls="$ref:$pfx"
      pfx="$pfx/"
      ;;
    *)
      ls="$ref"
      ;;
      esac

    case "$COMP_WORDBREAKS" in
    *:*) : great ;;
    *)   pfx="$ref:$pfx" ;;
    esac

    local IFS=$'\n'
    COMPREPLY=($(compgen -P "$pfx" \
      -W "$(git --git-dir="$(__gitdir)" ls-tree "$ls" \
        | sed '/^100... blob /{
                   s,^.*  ,,
                   s,$, ,
               }
               /^120000 blob /{
                   s,^.*  ,,
                   s,$, ,
               }
               /^040000 tree /{
                   s,^.*  ,,
                   s,$,/,
               }
               s/^.*  //')" \
      -- "$cur"))
    ;;
  *)
    __gitcomp "$(__git_refs)"
    ;;
  esac
}

__git_complete_revlist ()
{
  local pfx cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  *...*)
    pfx="${cur%...*}..."
    cur="${cur#*...}"
    __gitcomp "$(__git_refs)" "$pfx" "$cur"
    ;;
  *..*)
    pfx="${cur%..*}.."
    cur="${cur#*..}"
    __gitcomp "$(__git_refs)" "$pfx" "$cur"
    ;;
  *)
    __gitcomp "$(__git_refs)"
    ;;
  esac
}

__git_complete_remote_or_refspec ()
{
  local cmd="${COMP_WORDS[1]}"
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local i c=2 remote="" pfx="" lhs=1 no_complete_refspec=0
  while [ $c -lt $COMP_CWORD ]; do
    i="${COMP_WORDS[c]}"
    case "$i" in
    --mirror) [ "$cmd" = "push" ] && no_complete_refspec=1 ;;
    --all)
      case "$cmd" in
      push) no_complete_refspec=1 ;;
      fetch)
        COMPREPLY=()
        return
        ;;
      *) ;;
      esac
      ;;
    -*) ;;
    *) remote="$i"; break ;;
    esac
    c=$((++c))
  done
  if [ -z "$remote" ]; then
    __gitcomp "$(__git_remotes)"
    return
  fi
  if [ $no_complete_refspec = 1 ]; then
    COMPREPLY=()
    return
  fi
  [ "$remote" = "." ] && remote=
  case "$cur" in
  *:*)
    case "$COMP_WORDBREAKS" in
    *:*) : great ;;
    *)   pfx="${cur%%:*}:" ;;
    esac
    cur="${cur#*:}"
    lhs=0
    ;;
  +*)
    pfx="+"
    cur="${cur#+}"
    ;;
  esac
  case "$cmd" in
  fetch)
    if [ $lhs = 1 ]; then
      __gitcomp "$(__git_refs2 "$remote")" "$pfx" "$cur"
    else
      __gitcomp "$(__git_refs)" "$pfx" "$cur"
    fi
    ;;
  pull)
    if [ $lhs = 1 ]; then
      __gitcomp "$(__git_refs "$remote")" "$pfx" "$cur"
    else
      __gitcomp "$(__git_refs)" "$pfx" "$cur"
    fi
    ;;
  push)
    if [ $lhs = 1 ]; then
      __gitcomp "$(__git_refs)" "$pfx" "$cur"
    else
      __gitcomp "$(__git_refs "$remote")" "$pfx" "$cur"
    fi
    ;;
  esac
}

__git_complete_strategy ()
{
  __git_compute_merge_strategies
  case "${COMP_WORDS[COMP_CWORD-1]}" in
  -s|--strategy)
    __gitcomp "$__git_merge_strategies"
    return 0
  esac
  local cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  --strategy=*)
    __gitcomp "$__git_merge_strategies" "" "${cur##--strategy=}"
    return 0
    ;;
  esac
  return 1
}

__git_list_all_commands ()
{
  local i IFS=" "$'\n'
  for i in $(git help -a|egrep '^  [a-zA-Z0-9]')
  do
    case $i in
    *--*)             : helper pattern;;
    *) echo $i;;
    esac
  done
}

__git_all_commands=
__git_compute_all_commands ()
{
  : ${__git_all_commands:=$(__git_list_all_commands)}
}

__git_list_porcelain_commands ()
{
  local i IFS=" "$'\n'
  __git_compute_all_commands
  for i in "help" $__git_all_commands
  do
    case $i in
    *--*)             : helper pattern;;
    applymbox)        : ask gittus;;
    applypatch)       : ask gittus;;
    archimport)       : import;;
    cat-file)         : plumbing;;
    check-attr)       : plumbing;;
    check-ref-format) : plumbing;;
    checkout-index)   : plumbing;;
    commit-tree)      : plumbing;;
    count-objects)    : infrequent;;
    cvsexportcommit)  : export;;
    cvsimport)        : import;;
    cvsserver)        : daemon;;
    daemon)           : daemon;;
    diff-files)       : plumbing;;
    diff-index)       : plumbing;;
    diff-tree)        : plumbing;;
    fast-import)      : import;;
    fast-export)      : export;;
    fsck-objects)     : plumbing;;
    fetch-pack)       : plumbing;;
    fmt-merge-msg)    : plumbing;;
    for-each-ref)     : plumbing;;
    hash-object)      : plumbing;;
    http-*)           : transport;;
    index-pack)       : plumbing;;
    init-db)          : deprecated;;
    local-fetch)      : plumbing;;
    lost-found)       : infrequent;;
    ls-files)         : plumbing;;
    ls-remote)        : plumbing;;
    ls-tree)          : plumbing;;
    mailinfo)         : plumbing;;
    mailsplit)        : plumbing;;
    merge-*)          : plumbing;;
    mktree)           : plumbing;;
    mktag)            : plumbing;;
    pack-objects)     : plumbing;;
    pack-redundant)   : plumbing;;
    pack-refs)        : plumbing;;
    parse-remote)     : plumbing;;
    patch-id)         : plumbing;;
    peek-remote)      : plumbing;;
    prune)            : plumbing;;
    prune-packed)     : plumbing;;
    quiltimport)      : import;;
    read-tree)        : plumbing;;
    receive-pack)     : plumbing;;
    reflog)           : plumbing;;
    remote-*)         : transport;;
    repo-config)      : deprecated;;
    rerere)           : plumbing;;
    rev-list)         : plumbing;;
    rev-parse)        : plumbing;;
    runstatus)        : plumbing;;
    sh-setup)         : internal;;
    shell)            : daemon;;
    show-ref)         : plumbing;;
    send-pack)        : plumbing;;
    show-index)       : plumbing;;
    ssh-*)            : transport;;
    stripspace)       : plumbing;;
    symbolic-ref)     : plumbing;;
    tar-tree)         : deprecated;;
    unpack-file)      : plumbing;;
    unpack-objects)   : plumbing;;
    update-index)     : plumbing;;
    update-ref)       : plumbing;;
    update-server-info) : daemon;;
    upload-archive)   : plumbing;;
    upload-pack)      : plumbing;;
    write-tree)       : plumbing;;
    var)              : infrequent;;
    verify-pack)      : infrequent;;
    verify-tag)       : plumbing;;
    *) echo $i;;
    esac
  done
}

__git_porcelain_commands=
__git_compute_porcelain_commands ()
{
  __git_compute_all_commands
  : ${__git_porcelain_commands:=$(__git_list_porcelain_commands)}
}

__git_aliases ()
{
  local i IFS=$'\n'
  for i in $(git --git-dir="$(__gitdir)" config --get-regexp "alias\..*" 2>/dev/null); do
    case "$i" in
    alias.*)
      i="${i#alias.}"
      echo "${i/ */}"
      ;;
    esac
  done
}

# __git_aliased_command requires 1 argument
__git_aliased_command ()
{
  local word cmdline=$(git --git-dir="$(__gitdir)" \
    config --get "alias.$1")
  for word in $cmdline; do
    case "$word" in
    \!gitk|gitk)
      echo "gitk"
      return
      ;;
    \!*)  : shell command alias ;;
    -*)  : option ;;
    *=*)  : setting env ;;
    git)  : git itself ;;
    *)
      echo "$word"
      return
    esac
  done
}

# __git_find_on_cmdline requires 1 argument
__git_find_on_cmdline ()
{
  local word subcommand c=1

  while [ $c -lt $COMP_CWORD ]; do
    word="${COMP_WORDS[c]}"
    for subcommand in $1; do
      if [ "$subcommand" = "$word" ]; then
        echo "$subcommand"
        return
      fi
    done
    c=$((++c))
  done
}

__git_has_doubledash ()
{
  local c=1
  while [ $c -lt $COMP_CWORD ]; do
    if [ "--" = "${COMP_WORDS[c]}" ]; then
      return 0
    fi
    c=$((++c))
  done
  return 1
}

__git_whitespacelist="nowarn warn error error-all fix"

_git_am ()
{
  local cur="${COMP_WORDS[COMP_CWORD]}" dir="$(__gitdir)"
  if [ -d "$dir"/rebase-apply ]; then
    __gitcomp "--skip --continue --resolved --abort"
    return
  fi
  case "$cur" in
  --whitespace=*)
    __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}"
    return
    ;;
  --*)
    __gitcomp "
      --3way --committer-date-is-author-date --ignore-date
      --ignore-whitespace --ignore-space-change
      --interactive --keep --no-utf8 --signoff --utf8
      --whitespace= --scissors
      "
    return
  esac
  COMPREPLY=()
}

_git_apply ()
{
  local cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  --whitespace=*)
    __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}"
    return
    ;;
  --*)
    __gitcomp "
      --stat --numstat --summary --check --index
      --cached --index-info --reverse --reject --unidiff-zero
      --apply --no-add --exclude=
      --ignore-whitespace --ignore-space-change
      --whitespace= --inaccurate-eof --verbose
      "
    return
  esac
  COMPREPLY=()
}

_git_add ()
{
  __git_has_doubledash && return

  local cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  --*)
    __gitcomp "
      --interactive --refresh --patch --update --dry-run
      --ignore-errors --intent-to-add
      "
    return
  esac
  COMPREPLY=()
}

_git_archive ()
{
  local cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  --format=*)
    __gitcomp "$(git archive --list)" "" "${cur##--format=}"
    return
    ;;
  --remote=*)
    __gitcomp "$(__git_remotes)" "" "${cur##--remote=}"
    return
    ;;
  --*)
    __gitcomp "
      --format= --list --verbose
      --prefix= --remote= --exec=
      "
    return
    ;;
  esac
  __git_complete_file
}

_git_bisect ()
{
  __git_has_doubledash && return

  local subcommands="start bad good skip reset visualize replay log run"
  local subcommand="$(__git_find_on_cmdline "$subcommands")"
  if [ -z "$subcommand" ]; then
    __gitcomp "$subcommands"
    return
  fi

  case "$subcommand" in
  bad|good|reset|skip)
    __gitcomp "$(__git_refs)"
    ;;
  *)
    COMPREPLY=()
    ;;
  esac
}

_git_branch ()
{
  local i c=1 only_local_ref="n" has_r="n"

  while [ $c -lt $COMP_CWORD ]; do
    i="${COMP_WORDS[c]}"
    case "$i" in
    -d|-m)  only_local_ref="y" ;;
    -r)  has_r="y" ;;
    esac
    c=$((++c))
  done

  case "${COMP_WORDS[COMP_CWORD]}" in
  --*)
    __gitcomp "
      --color --no-color --verbose --abbrev= --no-abbrev
      --track --no-track --contains --merged --no-merged
      --set-upstream
      "
    ;;
  *)
    if [ $only_local_ref = "y" -a $has_r = "n" ]; then
      __gitcomp "$(__git_heads)"
    else
      __gitcomp "$(__git_refs)"
    fi
    ;;
  esac
}

_git_bundle ()
{
  local cmd="${COMP_WORDS[2]}"
  case "$COMP_CWORD" in
  2)
    __gitcomp "create list-heads verify unbundle"
    ;;
  3)
    # looking for a file
    ;;
  *)
    case "$cmd" in
      create)
        __git_complete_revlist
      ;;
    esac
    ;;
  esac
}

_git_checkout ()
{
  __git_has_doubledash && return

  local cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  --conflict=*)
    __gitcomp "diff3 merge" "" "${cur##--conflict=}"
    ;;
  --*)
    __gitcomp "
      --quiet --ours --theirs --track --no-track --merge
      --conflict= --orphan --patch
      "
    ;;
  *)
    __gitcomp "$(__git_refs)"
    ;;
  esac
}

_git_cherry ()
{
  __gitcomp "$(__git_refs)"
}

_git_cherry_pick ()
{
  local cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  --*)
    __gitcomp "--edit --no-commit"
    ;;
  *)
    __gitcomp "$(__git_refs)"
    ;;
  esac
}

_git_clean ()
{
  __git_has_doubledash && return

  local cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  --*)
    __gitcomp "--dry-run --quiet"
    return
    ;;
  esac
  COMPREPLY=()
}

_git_clone ()
{
  local cur="${COMP_WORDS[COMP_CWORD]}"
  case "$cur" in
  --*)
    __gitcomp "
      --local
      --no-hardlinks
      --shared
      --reference
      --quiet
      --no-checkout
      --bare
      --mirror
      --origin
      --upload-pack
      --template=